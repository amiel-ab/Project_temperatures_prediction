# -*- coding: utf-8 -*-
"""Projet_températures_terrestres.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r0w-zogcajNTat41Vm_pWdq0J39_gGvC
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv('GLB.Ts+dSST.csv',index_col=0,header=0)
df

df=df.drop(columns=['DJF','MAM','JJA','SON','D-N'])

df2= df[['J-D']]
df2

df3=df2.loc[df2.index>1959]
df3

fig, ax = plt.subplots(figsize=(15, 10))
sns.regplot(df2.index, df2['J-D'], data=df2, order=2, ci=None, scatter=False, color="red",label='regression polynomiale');
sns.lineplot(df2.index,df2['J-D'],data=df2,label='données brutes');

plt.xlabel('Années',fontsize=18)
plt.ylabel('température moyenne annuelle',fontsize=18)
plt.title('Evolution de la température moyenne en fonction des années',fontsize=20)

plt.legend(fontsize=18);
plt.show();

fig, ax = plt.subplots(figsize=(15, 10))
df_rol=df2.rolling(window=30,center=True).mean()
plt.plot(df_rol)
plt.title('Evolution de la température en fonction des années par moyenne mobile',fontsize=20)
plt.ylabel('Température (°C)',fontsize=16)
plt.xlabel('Années',fontsize=16)

#calcul de l'étendue (différence entre température maximale et minimale afin de mettre en évidence une éventuelle tendance)
df4=df.drop('J-D',axis=1)
etendue=df4.apply(lambda row: abs(row.max()-row.min()),axis=1)
etendue=pd.DataFrame(etendue)
etendue.rename(columns={0:'temp'}, inplace=True

plt.figure(figsize=(14,8))
sns.lineplot(etendue.index,etendue.temp,color="red",label='données brutes');
plt.xlabel('Années',fontsize=18);
plt.ylabel('Etendue',fontsize=18);
plt.title('Différence entre température maximale et minimale en fonction des années',fontsize=20);

#from statsmodels.tsa.arima_model import ARIMA
from statsmodels.tsa.arima.model import ARIMA


from sklearn.metrics import mean_squared_error
# Définir les paramètres du modèle ARIMA
p = 5  # ordre autoregression (AR)
d = 1  # ordre de différenciation
q = 0  # ordre moyenne mobile (MA)

# Regrouper les données pour la fréquence annuelle
#y = df2['J-D'].resample('A').mean().fillna(method='ffill')

# Ajuster le modèle ARIMA sur la série temporelle
model = ARIMA(df2, order=(p, d, q))
model_fit = model.fit()

# Faire une prévision pour les 5 prochaines années
forecast = model_fit.forecast(steps=5)

# Préparer les prévisions et les valeurs réelles pour l'évaluation
y_pred = forecast[0]
y_true = y[-5:]

# Calculer l'erreur quadratique moyenne (MSE)
mse = mean_squared_error(y_true, y_pred)
print("MSE: %.2f" % mse)

# Tracer les prévisions et les valeurs réelles sur un graphique
fig, ax = plt.subplots()
ax.plot(y.index[-10:], y[-10:], label='Données réelles')
ax.plot(y_true.index, y_pred, label='Prévisions', color='red')
plt.legend()
plt.show()

from pandas.plotting import autocorrelation_plot
pd.plotting.autocorrelation_plot(df2)

df_diff=df2.diff().dropna()

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20,7))
df_diff.plot(ax=ax1)
pd.plotting.autocorrelation_plot(df_diff, ax = ax2)

from statsmodels.tsa.stattools import adfuller
result = adfuller(df2)
print('Statistiques du test de Dickey-Fuller:', result[0])
print('p-value:', result[1])
if result[1] > 0.05:
    print('Les données ne sont pas stationnaires')
else:
    print('Les données sont stationnaires')

from statsmodels.tsa.statespace.sarimax import SARIMAX

# Load the dataframe


# Split the dataframe into training and testing sets
train = df3.loc[df3.index > 1960]
test = df3.loc[df3.index > 2022]

# Fit the SARIMA model to the training set
model = SARIMAX(train['J-D'], order=(1, 1, 1), seasonal_order=(1, 0, 1, 12))
model.fit()

# Make predictions on the testing set
predictions = model.predict(start=test.index[0], end=test.index[-1])

# Evaluate the model performance
rmse = np.sqrt(mean_squared_error(predictions, test['J-D']))
print('RMSE:', rmse)

from statsmodels.tsa.statespace.sarimax import SARIMAX as sm

import matplotlib.pyplot as plt

#test différenciation
df_diff=df_diff[df_diff.index>1960]

from statsmodels.graphics.tsaplots import plot_acf

plot_acf(df_diff)

constant = 1e-8
df_statio=np.log(df2['J-D']+constant)
df_statio=df_statio[df_statio.index>1960]

df_statio=df_statio[df_statio.index>1960]



df3.reset_index(inplace=True)
df3

import statsmodels.api as sm
model=sm.tsa.SARIMAX(df3['J-D'],order=(1,1,1),seasonal_order=(1,1,0,12))
sarima=model.fit()

# prédire les températures futures avec le modèle SARIMA
forecast = sarima.forecast(steps=47)


forecast=forecast.to_frame()

forecast.index=range(2023,2070)

forecast_steps = 47

# Construction d'intervals de confiances
forecast2 = sarima.get_forecast(steps=forecast_steps)
predicted_values = forecast2.predicted_mean
confidence_intervals = forecast2.conf_int()

confidence_intervals.index=range(2023,2070)

plt.plot(df2)
plt.plot(forecast,label='prévision')
plt.xlabel('Années')
plt.ylabel('Température en °C')
plt.plot(confidence_intervals,label='intervalle de confiance')
plt.axvline(x=2024,color='r')
plt.title('')
plt.legend()
plt.show();

fig, ax = plt.subplots(figsize=(10, 6))

#courbes d'intervalle de confiance
ax.plot(confidence_intervals.index,confidence_intervals.values, color='grey', linestyle='--', label='Upper Bound')


# air entre les courbes d'intervalle de confiance
ax.fill_between(forecast.index,forecast.values, color='lightgrey', alpha=0.5)


ax.plot(x, predicted_values, color='blue', label='Predicted Values')


ax.set_title("Prédictions avec intervalles de confiance")
ax.set_xlabel("Temps")
ax.set_ylabel("Valeur")
plt.legend(loc="upper left")


plt.show()

dff=df2+forecast.loc[1:]

dff=pd.concat([df2,forecast])

df_merged = dff['J-D'].combine_first(dff['predicted_mean'])

dff_rol=df_merged.rolling(window=8,center=True).mean()
fig, ax = plt.subplots()
plt.plot(dff_rol)
plt.axvline(x=2024,color='r')
plt.ylim(-0.5,1.8)

df_rmse=df3.loc[df3['Year']>1975]

df3

errors = np.array(df_rmse['J-D']) - np.array(predicted_values)

# Calcul du RMSE
rmse = np.sqrt(np.mean(errors**2))

print("RMSE :", rmse)

#on note qu'avec une prédiction sur 34 ans soit jusqu'en 2056 le RMSE est de 0.61 soit un erreur minorée par rapport
# à une prédiction sur 48 ans ( jusque 2070)


#faire intervalle de confiance
# tester robustesse à partir de la variable cible sur des periodes dont on connait deja les valeurs de température

#test

# Convertir la colonne "année" en type datetime
model = sm.tsa.statespace.SARIMAX(df3["J-D"], order=(1,1,1), seasonal_order=(0,1,1,12)).fit()

# Accéder aux résidus
residus = model.resid

residuals = model.resid
std_dev = np.std(residuals)
interval = 1.96 * std_dev
lower_bound = forecast - interval
upper_bound = forecast + interval

#test
plt.plot(df2)
plt.plot(forecast, color='red')
plt.fill_between(forecast.index, lower_bound, upper_bound, color='gray', alpha=0.2)
plt.show()

# Calculer l'intervalle de confiance à 95%
residuals = forecast.resid
std_dev = np.std(residuals)
interval = 1.96 * std_dev
lower_bound = forecast - interval
upper_bound = forecast + interval

# intervalle de confiance
plt.plot(data)
plt.plot(forecast, color='red')
plt.fill_between(forecast.index, lower_bound, upper_bound, color='gray', alpha=0.2)
plt.show()

#test
prediction = sarima.get_forecast(steps =67).summary_frame()  #Prédiction avec intervalle de confiance

fig, ax = plt.subplots(figsize = (15,5))

plt.plot(forecast_values,start=2022)
 #Passage à l'exponentielle

# predictions température
forecast = sarima_fit.get_prediction(start=2022, end=2050)

# extraction données
forecast_values = forecast.predicted_mean
ci = forecast.conf_int()

prediction['mean'].plot(ax = ax, style = 'k--') #Visualisation de la moyenne

ax.fill_between(prediction.index, prediction['mean_ci_lower'], prediction['mean_ci_upper'], color='k', alpha=0.1);

forecast_values=forecast_values.apply(lambda x: x-15)

forecast